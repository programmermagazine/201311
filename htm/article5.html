<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <meta name="generator" content="pandoc" />
  <title></title>
  <style type="text/css">code{white-space: pre;}</style>
  <style type="text/css">
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
table.sourceCode { width: 100%; line-height: 100%; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
code > span.kw { color: #007020; font-weight: bold; }
code > span.dt { color: #902000; }
code > span.dv { color: #40a070; }
code > span.bn { color: #40a070; }
code > span.fl { color: #40a070; }
code > span.ch { color: #4070a0; }
code > span.st { color: #4070a0; }
code > span.co { color: #60a0b0; font-style: italic; }
code > span.ot { color: #007020; }
code > span.al { color: #ff0000; font-weight: bold; }
code > span.fu { color: #06287e; }
code > span.er { color: #ff0000; font-weight: bold; }
  </style>
  <link rel="stylesheet" href="../css/pmag.css" type="text/css" />
</head>
<body>
<div id="header_wrap">
   <h1><a href="https://www.facebook.com/groups/programmerMagazine">程式人雜誌</a> <sub> --  <a href="https://dl.dropbox.com/u/101584453/pmag/201311/htm/home.html">2013 年 11 月號</a> (開放公益出版品)</sub></h1>
</div>
<div id="content">
<div id="TOC">
<ul>
<li><a href="#開放電腦計畫-5-支援完整指令集的-cpu0sc-處理器使用-verilog-實作-作者陳鍾誠">開放電腦計畫 (5) – 支援完整指令集的 CPU0sc 處理器：使用 Verilog 實作 (作者：陳鍾誠)</a></li>
</ul>
</div>
<h2 id="開放電腦計畫-5-支援完整指令集的-cpu0sc-處理器使用-verilog-實作-作者陳鍾誠"><a href="#開放電腦計畫-5-支援完整指令集的-cpu0sc-處理器使用-verilog-實作-作者陳鍾誠">開放電腦計畫 (5) – 支援完整指令集的 CPU0sc 處理器：使用 Verilog 實作 (作者：陳鍾誠)</a></h2>
<h3 id="簡介"><a href="#簡介">簡介</a></h3>
<p>在上一期當中，我們用 Verilog 設計了一個只有四個指令的簡化版處理器 CPU0mc.v ，文章網址如下：</p>
<ul>
<li><a href="https://dl.dropboxusercontent.com/u/101584453/pmag/201310/htm/article5.html">開放電腦計畫 (4) – CPU0mc 處理器：使用 Verilog 實作</a></li>
</ul>
<p>如果您讀過上述文章，應該已經瞭解如何用 Verilog 設計簡單的指令與 CPU 了。在本文中，我們將延續 上期的主題，更深入的說明如何用 Verilog 設計出一顆具有完整指令集的處理器 -- CPU0sc.v 。</p>
<h3 id="程式碼"><a href="#程式碼">程式碼</a></h3>
<p>我們只要將上期的 CPU0mc 繼續延伸，加入更多的指令實作，就能做出具有完整指令集的處理器 CPU0sc.v，以下是 處理器 CPU0sc.v 的完整 Verilog 原始碼。</p>
<p>檔案：cpu0sc.v</p>
<pre class="sourceCode verilog"><code class="sourceCode verilog"><span class="ot">`define PC   R[15]   </span><span class="co">// 程式計數器</span>
<span class="ot">`define LR   R[14]   </span><span class="co">// 連結暫存器</span>
<span class="ot">`define SP   R[13]   </span><span class="co">// 堆疊暫存器</span>
<span class="ot">`define SW   R[12]   </span><span class="co">// 狀態暫存器</span>
<span class="co">// 狀態暫存器旗標位元</span>
<span class="ot">`define N    `SW[31] </span><span class="co">// 負號旗標</span>
<span class="ot">`define Z    `SW[30] </span><span class="co">// 零旗標</span>
<span class="ot">`define C    `SW[29] </span><span class="co">// 進位旗標</span>
<span class="ot">`define V    `SW[28] </span><span class="co">// 溢位旗標</span>
<span class="ot">`define I    `SW[7]  </span><span class="co">// 硬體中斷許可</span>
<span class="ot">`define T    `SW[6]  </span><span class="co">// 軟體中斷許可</span>
<span class="ot">`define M    `SW[0]  </span><span class="co">// 模式位元</span>

<span class="kw">module</span> cpu0c(<span class="dt">input</span> clock); <span class="co">// CPU0-Mini 的快取版：cpu0mc 模組</span>
  <span class="dt">parameter</span> [<span class="dv">7</span>:<span class="dv">0</span>] LD=<span class="bn">8&#39;h00</span>,ST=<span class="bn">8&#39;h01</span>,LDB=<span class="bn">8&#39;h02</span>,STB=<span class="bn">8&#39;h03</span>,LDR=<span class="bn">8&#39;h04</span>,STR=<span class="bn">8&#39;h05</span>,
    LBR=<span class="bn">8&#39;h06</span>,SBR=<span class="bn">8&#39;h07</span>,ADDI=<span class="bn">8&#39;h08</span>,CMP=<span class="bn">8&#39;h10</span>,MOV=<span class="bn">8&#39;h12</span>,ADD=<span class="bn">8&#39;h13</span>,SUB=<span class="bn">8&#39;h14</span>,
    MUL=<span class="bn">8&#39;h15</span>,DIV=<span class="bn">8&#39;h16</span>,AND=<span class="bn">8&#39;h18</span>,OR=<span class="bn">8&#39;h19</span>,XOR=<span class="bn">8&#39;h1A</span>,ROL=<span class="bn">8&#39;h1C</span>,ROR=<span class="bn">8&#39;h1D</span>,
    SHL=<span class="bn">8&#39;h1E</span>,SHR=<span class="bn">8&#39;h1F</span>,JEQ=<span class="bn">8&#39;h20</span>,JNE=<span class="bn">8&#39;h21</span>,JLT=<span class="bn">8&#39;h22</span>,JGT=<span class="bn">8&#39;h23</span>,JLE=<span class="bn">8&#39;h24</span>,
    JGE=<span class="bn">8&#39;h25</span>,JMP=<span class="bn">8&#39;h26</span>,SWI=<span class="bn">8&#39;h2A</span>,CALL=<span class="bn">8&#39;h2B</span>,RET=<span class="bn">8&#39;h2C</span>,IRET=<span class="bn">8&#39;h2D</span>,
    PUSH=<span class="bn">8&#39;h30</span>,POP=<span class="bn">8&#39;h31</span>,PUSHB=<span class="bn">8&#39;h32</span>,POPB=<span class="bn">8&#39;h33</span>;
  <span class="dt">reg</span> <span class="dt">signed</span> [<span class="dv">31</span>:<span class="dv">0</span>] R [<span class="dv">0</span>:<span class="dv">15</span>];   <span class="co">// 宣告暫存器 R[0..15] 等 16 個 32 位元暫存器</span>
  <span class="dt">reg</span> <span class="dt">signed</span> [<span class="dv">31</span>:<span class="dv">0</span>] IR;         <span class="co">// 指令暫存器 IR</span>
  <span class="dt">reg</span> [<span class="dv">7</span>:<span class="dv">0</span>] m [<span class="dv">0</span>:<span class="dv">256</span>];          <span class="co">// 內部的快取記憶體</span>
  <span class="dt">reg</span> [<span class="dv">7</span>:<span class="dv">0</span>] op;                 <span class="co">// 變數：運算代碼 op</span>
  <span class="dt">reg</span> [<span class="dv">3</span>:<span class="dv">0</span>] ra, rb, rc;         <span class="co">// 變數：暫存器代號 ra, rb, rc</span>
  <span class="dt">reg</span> [<span class="dv">4</span>:<span class="dv">0</span>] c5;                 <span class="co">// 變數：5 位元常數 c5</span>
  <span class="dt">reg</span> <span class="dt">signed</span> [<span class="dv">11</span>:<span class="dv">0</span>] c12;        <span class="co">// 變數：12 位元常數 c12</span>
  <span class="dt">reg</span> <span class="dt">signed</span> [<span class="dv">15</span>:<span class="dv">0</span>] c16;        <span class="co">// 變數：16 位元常數 c16</span>
  <span class="dt">reg</span> <span class="dt">signed</span> [<span class="dv">23</span>:<span class="dv">0</span>] c24;        <span class="co">// 變數：24 位元常數 c24</span>
  <span class="dt">reg</span> <span class="dt">signed</span> [<span class="dv">31</span>:<span class="dv">0</span>] sp, jaddr, laddr, raddr;
  <span class="dt">reg</span> <span class="dt">signed</span> [<span class="dv">31</span>:<span class="dv">0</span>] temp;
  <span class="dt">reg</span> <span class="dt">signed</span> [<span class="dv">31</span>:<span class="dv">0</span>] pc;

  <span class="dt">integer</span> i;  
  <span class="kw">initial</span>  <span class="co">// 初始化</span>
  <span class="kw">begin</span>
    <span class="ot">`PC</span> = <span class="dv">0</span>;                    <span class="co">// 將 PC 設為起動位址 0</span>
    <span class="ot">`SW</span> = <span class="dv">0</span>;
    R[<span class="dv">0</span>] = <span class="dv">0</span>;                   <span class="co">// 將 R[0] 暫存器強制設定為 0</span>
    <span class="dt">$readmemh</span>(<span class="st">&quot;cpu0s.hex&quot;</span>, m);
    <span class="kw">for</span> (i=<span class="dv">0</span>; i &lt; <span class="dv">255</span>; i=i<span class="dv">+4</span>) <span class="kw">begin</span>
       <span class="dt">$display</span>(<span class="st">&quot;%8x: %8x&quot;</span>, i, {m[i], m[i<span class="dv">+1</span>], m[i<span class="dv">+2</span>], m[i<span class="dv">+3</span>]});
    <span class="kw">end</span>
  <span class="kw">end</span>
  
  <span class="kw">always</span> @(<span class="kw">posedge</span> clock) <span class="kw">begin</span> <span class="co">// 在 clock 時脈的正邊緣時觸發</span>
      pc = <span class="ot">`PC</span>;
      IR = {m[<span class="ot">`PC</span>], m[<span class="ot">`PC</span><span class="dv">+1</span>], m[<span class="ot">`PC</span><span class="dv">+2</span>], m[<span class="ot">`PC</span><span class="dv">+3</span>]};  <span class="co">// 指令擷取階段：IR=m[PC], 4 個 Byte 的記憶體</span>
      <span class="ot">`PC</span> = <span class="ot">`PC</span><span class="dv">+4</span>;                                  <span class="co">// 擷取完成，PC 前進到下一個指令位址</span>
      {op,ra,rb,rc,c12} = IR;                      <span class="co">// 解碼階段：將 IR 解為 {op, ra, rb, rc, c12}</span>
      c5  = IR[<span class="dv">4</span>:<span class="dv">0</span>];
      c24 = IR[<span class="dv">23</span>:<span class="dv">0</span>];
      c16 = IR[<span class="dv">15</span>:<span class="dv">0</span>];
      jaddr = <span class="ot">`PC</span>+c16;
      laddr = R[rb]+c16;
      raddr = R[rb]+R[rc];
      <span class="kw">case</span> (op) <span class="co">// 根據 OP 執行對應的動作</span>
        <span class="dv">LD:</span> <span class="kw">begin</span>   <span class="co">// 載入指令： R[ra] = m[addr]</span>
          R[ra] = {m[laddr], m[laddr<span class="dv">+1</span>], m[laddr<span class="dv">+2</span>], m[laddr<span class="dv">+3</span>]};
          <span class="dt">$display</span>(<span class="st">&quot;%4dns %8x : LD    R%-d R%-d 0x%x ; R%-2d=0x%8x=%-d&quot;</span>, <span class="dt">$stime</span>, pc, ra, rb, c16, ra, R[ra], R[ra]);
          <span class="kw">end</span>
        <span class="dv">ST:</span> <span class="kw">begin</span>   <span class="co">// 儲存指令： m[addr] = R[ra]</span>
          {m[laddr], m[laddr<span class="dv">+1</span>], m[laddr<span class="dv">+2</span>], m[laddr<span class="dv">+3</span>]} = R[ra];
          <span class="dt">$display</span>(<span class="st">&quot;%4dns %8x : ST    R%-d R%-d 0x%x ; R%-2d=0x%8x=%-d&quot;</span>, <span class="dt">$stime</span>, pc, ra, rb, c16, ra, R[ra], R[ra]);
          <span class="kw">end</span>
        <span class="dv">LDB:</span><span class="kw">begin</span>   <span class="co">// 載入byte;     LDB Ra, [Rb+ Cx];   Ra&lt;=(byte)[Rb+ Cx]</span>
          R[ra] = { <span class="bn">24&#39;b0</span>, m[laddr] };
          <span class="dt">$display</span>(<span class="st">&quot;%4dns %8x : LDB   R%-d R%-d 0x%x ; R%-2d=0x%8x=%-d&quot;</span>, <span class="dt">$stime</span>, pc, ra, rb, c16, ra, R[ra], R[ra]);
          <span class="kw">end</span>
        <span class="dv">STB:</span><span class="kw">begin</span>   <span class="co">// 儲存byte;     STB Ra, [Rb+ Cx];   Ra=&gt;(byte)[Rb+ Cx]</span>
          m[laddr] = R[ra][<span class="dv">7</span>:<span class="dv">0</span>];
          <span class="dt">$display</span>(<span class="st">&quot;%4dns %8x : STB   R%-d R%-d 0x%x ; R%-2d=0x%8x=%-d&quot;</span>, <span class="dt">$stime</span>, pc, ra, rb, c16, ra, R[ra], R[ra]);
          <span class="kw">end</span>
        <span class="dv">LDR:</span><span class="kw">begin</span>   <span class="co">// LD 的 Rc 版;  LDR Ra, [Rb+Rc];    Ra&lt;=[Rb+ Rc]</span>
          R[ra] = {m[raddr], m[raddr<span class="dv">+1</span>], m[raddr<span class="dv">+2</span>], m[raddr<span class="dv">+3</span>]};
          <span class="dt">$display</span>(<span class="st">&quot;%4dns %8x : LDR   R%-d R%-d R%-d    ; R%-2d=0x%8x=%-d&quot;</span>, <span class="dt">$stime</span>, pc, ra, rb, rc, ra, R[ra], R[ra]);
          <span class="kw">end</span>
        <span class="dv">STR:</span><span class="kw">begin</span>   <span class="co">// ST 的 Rc 版;  STR Ra, [Rb+Rc];    Ra=&gt;[Rb+ Rc]</span>
          {m[raddr], m[raddr<span class="dv">+1</span>], m[raddr<span class="dv">+2</span>], m[raddr<span class="dv">+3</span>]} = R[ra];
          <span class="dt">$display</span>(<span class="st">&quot;%4dns %8x : STR   R%-d R%-d R%-d    ; R%-2d=0x%8x=%-d&quot;</span>, <span class="dt">$stime</span>, pc, ra, rb, rc, ra, R[ra], R[ra]);
          <span class="kw">end</span>
        <span class="dv">LBR:</span><span class="kw">begin</span>   <span class="co">// LDB 的 Rc 版; LBR Ra, [Rb+Rc];    Ra&lt;=(byte)[Rb+ Rc]</span>
          R[ra] = { <span class="bn">24&#39;b0</span>, m[raddr] };
          <span class="dt">$display</span>(<span class="st">&quot;%4dns %8x : LBR   R%-d R%-d R%-d    ; R%-2d=0x%8x=%-d&quot;</span>, <span class="dt">$stime</span>, pc, ra, rb, rc, ra, R[ra], R[ra]);
          <span class="kw">end</span>
        <span class="dv">SBR:</span><span class="kw">begin</span>   <span class="co">// STB 的 Rc 版; SBR Ra, [Rb+Rc];    Ra=&gt;(byte)[Rb+ Rc]</span>
          m[raddr] = R[ra][<span class="dv">7</span>:<span class="dv">0</span>];
          <span class="dt">$display</span>(<span class="st">&quot;%4dns %8x : SBR   R%-d R%-d R%-d    ; R%-2d=0x%8x=%-d&quot;</span>, <span class="dt">$stime</span>, pc, ra, rb, rc, ra, R[ra], R[ra]);
          <span class="kw">end</span>
        <span class="dv">MOV:</span><span class="kw">begin</span>   <span class="co">// 移動;        MOV Ra, Rb;         Ra&lt;=Rb</span>
          R[ra] = R[rb];
          <span class="dt">$display</span>(<span class="st">&quot;%4dns %8x : MOV   R%-d R%-d        ; R%-2d=0x%8x=%-d&quot;</span>, <span class="dt">$stime</span>, pc, ra, rb, ra, R[ra], R[ra]);
          <span class="kw">end</span>
        <span class="dv">CMP:</span><span class="kw">begin</span>   <span class="co">// 比較;        CMP Ra, Rb;         SW=(Ra &gt;=&lt; Rb)</span>
          temp = R[ra]-R[rb];
          <span class="ot">`N</span>=(temp&lt;<span class="dv">0</span>);<span class="ot">`Z</span>=(temp==<span class="dv">0</span>);
          <span class="dt">$display</span>(<span class="st">&quot;%4dns %8x : CMP   R%-d R%-d        ; SW=0x%x&quot;</span>, <span class="dt">$stime</span>, pc, ra, rb, <span class="ot">`SW</span>);
          <span class="kw">end</span>
        <span class="dv">ADDI:</span><span class="kw">begin</span>  <span class="co">// R[a] = Rb+c16;  // 立即值加法;   LDI Ra, Rb+Cx; Ra&lt;=Rb + Cx</span>
          R[ra] = R[rb]+c16;
          <span class="dt">$display</span>(<span class="st">&quot;%4dns %8x : ADDI  R%-d R%-d %-d ; R%-2d=0x%8x=%-d&quot;</span>, <span class="dt">$stime</span>, pc, ra, rb, c16, ra, R[ra], R[ra]);
          <span class="kw">end</span>
        <span class="dv">ADD:</span> <span class="kw">begin</span>  <span class="co">// 加法指令： R[ra] = R[rb]+R[rc]</span>
          R[ra] = R[rb]+R[rc];
          <span class="dt">$display</span>(<span class="st">&quot;%4dns %8x : ADD   R%-d R%-d R%-d    ; R%-2d=0x%8x=%-d&quot;</span>, <span class="dt">$stime</span>, pc, ra, rb, rc, ra, R[ra], R[ra]);
          <span class="kw">end</span>
        <span class="dv">SUB:</span><span class="kw">begin</span>   <span class="co">// 減法;        SUB Ra, Rb, Rc;     Ra&lt;=Rb-Rc</span>
          R[ra] = R[rb]-R[rc];
          <span class="dt">$display</span>(<span class="st">&quot;%4dns %8x : SUB   R%-d R%-d R%-d    ; R%-2d=0x%8x=%-d&quot;</span>, <span class="dt">$stime</span>, pc, ra, rb, rc, ra, R[ra], R[ra]);
          <span class="kw">end</span>
        <span class="dv">MUL:</span><span class="kw">begin</span>   <span class="co">// 乘法;        MUL Ra, Rb, Rc;     Ra&lt;=Rb*Rc</span>
          R[ra] = R[rb]*R[rc];
          <span class="dt">$display</span>(<span class="st">&quot;%4dns %8x : MUL   R%-d R%-d R%-d    ; R%-2d=0x%8x=%-d&quot;</span>, <span class="dt">$stime</span>, pc, ra, rb, rc, ra, R[ra], R[ra]);
          <span class="kw">end</span>
        <span class="dv">DIV:</span><span class="kw">begin</span>   <span class="co">// 除法;        DIV Ra, Rb, Rc;     Ra&lt;=Rb/Rc</span>
          R[ra] = R[rb]/R[rc];
          <span class="dt">$display</span>(<span class="st">&quot;%4dns %8x : DIV   R%-d R%-d R%-d    ; R%-2d=0x%8x=%-d&quot;</span>, <span class="dt">$stime</span>, pc, ra, rb, rc, ra, R[ra], R[ra]);
          <span class="kw">end</span>
        <span class="dv">AND:</span><span class="kw">begin</span>   <span class="co">// 位元 AND;    AND Ra, Rb, Rc;     Ra&lt;=Rb and Rc</span>
          R[ra] = R[rb]&amp;R[rc];
          <span class="dt">$display</span>(<span class="st">&quot;%4dns %8x : AND   R%-d R%-d R%-d    ; R%-2d=0x%8x=%-d&quot;</span>, <span class="dt">$stime</span>, pc, ra, rb, rc, ra, R[ra], R[ra]);
          <span class="kw">end</span>
        <span class="dv">OR:</span><span class="kw">begin</span>    <span class="co">// 位元 OR;     OR Ra, Rb, Rc;         Ra&lt;=Rb or Rc</span>
          R[ra] = R[rb]|R[rc];
          <span class="dt">$display</span>(<span class="st">&quot;%4dns %8x : OR    R%-d R%-d R%-d    ; R%-2d=0x%8x=%-d&quot;</span>, <span class="dt">$stime</span>, pc, ra, rb, rc, ra, R[ra], R[ra]);
          <span class="kw">end</span>
        <span class="dv">XOR:</span><span class="kw">begin</span>   <span class="co">// 位元 XOR;    XOR Ra, Rb, Rc;     Ra&lt;=Rb xor Rc</span>
          R[ra] = R[rb]^R[rc];
          <span class="dt">$display</span>(<span class="st">&quot;%4dns %8x : XOR   R%-d R%-d R%-d    ; R%-2d=0x%8x=%-d&quot;</span>, <span class="dt">$stime</span>, pc, ra, rb, rc, ra, R[ra], R[ra]);
          <span class="kw">end</span>
        <span class="dv">SHL:</span><span class="kw">begin</span>   <span class="co">// 向左移位;    SHL Ra, Rb, Cx;     Ra&lt;=Rb &lt;&lt; Cx</span>
          R[ra] = R[rb]&lt;&lt;c5;
          <span class="dt">$display</span>(<span class="st">&quot;%4dns %8x : SHL   R%-d R%-d %-d     ; R%-2d=0x%8x=%-d&quot;</span>, <span class="dt">$stime</span>, pc, ra, rb, c5, ra, R[ra], R[ra]);
          <span class="kw">end</span>
        <span class="dv">SHR:</span><span class="kw">begin</span>   <span class="co">// 向右移位;        SHR Ra, Rb, Cx;     Ra&lt;=Rb &gt;&gt; Cx</span>
          R[ra] = R[rb]&gt;&gt;c5;
          <span class="dt">$display</span>(<span class="st">&quot;%4dns %8x : SHR   R%-d R%-d %-d     ; R%-2d=0x%8x=%-d&quot;</span>, <span class="dt">$stime</span>, pc, ra, rb, c5, ra, R[ra], R[ra]);
          <span class="kw">end</span>          
        <span class="dv">JMP:</span><span class="kw">begin</span>   <span class="co">// 跳躍指令： PC = PC + cx24</span>
          <span class="ot">`PC</span> = <span class="ot">`PC</span> + c24;
          <span class="dt">$display</span>(<span class="st">&quot;%4dns %8x : JMP   0x%x       ; PC=0x%x&quot;</span>, <span class="dt">$stime</span>, pc, c24, <span class="ot">`PC</span>);
          <span class="kw">end</span>
        <span class="dv">JEQ:</span><span class="kw">begin</span>   <span class="co">// 跳躍 (相等);        JEQ Cx;        if SW(=) PC  PC+Cx</span>
          <span class="kw">if</span> (<span class="ot">`Z</span>) <span class="ot">`PC</span>=<span class="ot">`PC</span>+c24;
          <span class="dt">$display</span>(<span class="st">&quot;%4dns %8x : JEQ   0x%08x     ; PC=0x%x&quot;</span>, <span class="dt">$stime</span>, pc, c24, <span class="ot">`PC</span>);
          <span class="kw">end</span>
        <span class="dv">JNE:</span><span class="kw">begin</span>   <span class="co">// 跳躍 (不相等);    JNE Cx;     if SW(!=) PC  PC+Cx</span>
          <span class="kw">if</span> (!<span class="ot">`Z</span>) <span class="ot">`PC</span>=<span class="ot">`PC</span>+c24;
          <span class="dt">$display</span>(<span class="st">&quot;%4dns %8x : JNE   0x%08x     ; PC=0x%x&quot;</span>, <span class="dt">$stime</span>, pc, c24, <span class="ot">`PC</span>);
          <span class="kw">end</span>
        <span class="dv">JLT:</span><span class="kw">begin</span>   <span class="co">// 跳躍 ( &lt; );        JLT Cx;     if SW(&lt;) PC  PC+Cx</span>
          <span class="kw">if</span> (<span class="ot">`N</span>) <span class="ot">`PC</span>=<span class="ot">`PC</span>+c24;
          <span class="dt">$display</span>(<span class="st">&quot;%4dns %8x : JLT   0x%08x     ; PC=0x%x&quot;</span>, <span class="dt">$stime</span>, pc, c24, <span class="ot">`PC</span>);
          <span class="kw">end</span>
        <span class="dv">JGT:</span><span class="kw">begin</span>   <span class="co">// 跳躍 ( &gt; );        JGT Cx;     if SW(&gt;) PC  PC+Cx</span>
          <span class="kw">if</span> (!<span class="ot">`N</span>&amp;&amp;!<span class="ot">`Z</span>) <span class="ot">`PC</span>=<span class="ot">`PC</span>+c24;
          <span class="dt">$display</span>(<span class="st">&quot;%4dns %8x : JGT   0x%08x     ; PC=0x%x&quot;</span>, <span class="dt">$stime</span>, pc, c24, <span class="ot">`PC</span>);
          <span class="kw">end</span>
        <span class="dv">JLE:</span><span class="kw">begin</span>   <span class="co">// 跳躍 ( &lt;= );        JLE Cx;     if SW(&lt;=) PC  PC+Cx  </span>
          <span class="kw">if</span> (<span class="ot">`N</span> || <span class="ot">`Z</span>) <span class="ot">`PC</span>=<span class="ot">`PC</span>+c24;
          <span class="dt">$display</span>(<span class="st">&quot;%4dns %8x : JLE   0x%08x     ; PC=0x%x&quot;</span>, <span class="dt">$stime</span>, pc, c24, <span class="ot">`PC</span>);
          <span class="kw">end</span>
        <span class="dv">JGE:</span><span class="kw">begin</span>   <span class="co">// 跳躍 ( &gt;= );        JGE Cx;     if SW(&gt;=) PC  PC+Cx</span>
          <span class="kw">if</span> (!<span class="ot">`N</span> || <span class="ot">`Z</span>) <span class="ot">`PC</span>=<span class="ot">`PC</span>+c24;
          <span class="dt">$display</span>(<span class="st">&quot;%4dns %8x : JGE   0x%08x     ; PC=0x%x&quot;</span>, <span class="dt">$stime</span>, pc, c24, <span class="ot">`PC</span>);
          <span class="kw">end</span>
        <span class="dv">SWI:</span><span class="kw">begin</span>   <span class="co">// 軟中斷;    SWI Cx;         LR &lt;= PC; PC &lt;= Cx; INT&lt;=1</span>
          <span class="ot">`LR</span>=<span class="ot">`PC</span>;<span class="ot">`PC</span>= c24; <span class="ot">`I</span> = <span class="bn">1&#39;b1</span>;
          <span class="dt">$display</span>(<span class="st">&quot;%4dns %8x : SWI   0x%08x     ; PC=0x%x&quot;</span>, <span class="dt">$stime</span>, pc, c24, <span class="ot">`PC</span>);
          <span class="kw">end</span>
        <span class="dv">CALL:</span><span class="kw">begin</span>  <span class="co">// 跳到副程式;    CALL Cx;     LR&lt;=PC; PC&lt;=PC+Cx</span>
          <span class="ot">`LR</span>=<span class="ot">`PC</span>;<span class="ot">`PC</span>=<span class="ot">`PC</span> + c24;
          <span class="dt">$display</span>(<span class="st">&quot;%4dns %8x : CALL  0x%08x     ; PC=0x%x&quot;</span>, <span class="dt">$stime</span>, pc, c24, <span class="ot">`PC</span>);
          <span class="kw">end</span>
        <span class="dv">RET:</span><span class="kw">begin</span>   <span class="co">// 返回;            RET;         PC &lt;= LR</span>
          <span class="ot">`PC</span>=<span class="ot">`LR</span>;
          <span class="dt">$display</span>(<span class="st">&quot;%4dns %8x : RET                  ; PC=0x%x&quot;</span>, <span class="dt">$stime</span>, pc, <span class="ot">`PC</span>);
          <span class="kw">if</span> (<span class="ot">`PC</span>&lt;<span class="dv">0</span>) <span class="dt">$finish</span>;
          <span class="kw">end</span>
        <span class="dv">IRET:</span><span class="kw">begin</span>  <span class="co">// 中斷返回;        IRET;         PC &lt;= LR; INT&lt;=0</span>
          <span class="ot">`PC</span>=<span class="ot">`LR</span>;<span class="ot">`I</span> = <span class="bn">1&#39;b0</span>;
          <span class="dt">$display</span>(<span class="st">&quot;%4dns %8x : IRET             ; PC=0x%x&quot;</span>, <span class="dt">$stime</span>, pc, <span class="ot">`PC</span>);
          <span class="kw">end</span>
        <span class="dv">PUSH:</span><span class="kw">begin</span>  <span class="co">// 推入 word;    PUSH Ra;    SP-=4;[SP]&lt;=Ra;</span>
          sp = <span class="ot">`SP</span><span class="dv">-4</span>; <span class="ot">`SP</span> = sp; {m[sp], m[sp<span class="dv">+1</span>], m[sp<span class="dv">+2</span>], m[sp<span class="dv">+3</span>]} = R[ra];
          <span class="dt">$display</span>(<span class="st">&quot;%4dns %8x : PUSH  R%-d            ; R%-2d=0x%8x, SP=0x%x&quot;</span>, <span class="dt">$stime</span>, pc, ra, ra, R[ra], <span class="ot">`SP</span>);
          <span class="kw">end</span>
        <span class="dv">POP:</span><span class="kw">begin</span>   <span class="co">// 彈出 word;    POP Ra;     Ra=[SP];SP+=4;</span>
          sp = <span class="ot">`SP</span>; R[ra]={m[sp], m[sp<span class="dv">+1</span>], m[sp<span class="dv">+2</span>], m[sp<span class="dv">+3</span>]}; <span class="ot">`SP</span> = sp<span class="dv">+4</span>; 
          <span class="dt">$display</span>(<span class="st">&quot;%4dns %8x : POP   R%-d            ; R%-2d=0x%8x, SP=0x%x&quot;</span>, <span class="dt">$stime</span>, pc, ra, ra, R[ra], <span class="ot">`SP</span>);
          <span class="kw">end</span>
        <span class="dv">PUSHB:</span><span class="kw">begin</span> <span class="co">// 推入 byte;    PUSHB Ra;   SP--;[SP]&lt;=Ra;(byte)</span>
          sp = <span class="ot">`SP</span><span class="dv">-1</span>; <span class="ot">`SP</span> = sp; m[sp] = R[ra];
          <span class="dt">$display</span>(<span class="st">&quot;%4dns %8x : PUSHB R%-d            ; R[%-d]=0x%8x, SP=0x%x&quot;</span>, <span class="dt">$stime</span>, pc, ra, ra, R[ra], <span class="ot">`SP</span>);
          <span class="kw">end</span>
        <span class="dv">POPB:</span><span class="kw">begin</span>  <span class="co">// 彈出 byte;    POPB Ra;  Ra&lt;=[SP];SP++;(byte)</span>
          sp = <span class="ot">`SP</span><span class="dv">+1</span>; <span class="ot">`SP</span> = sp; R[ra]=m[sp];
          <span class="dt">$display</span>(<span class="st">&quot;%4dns %8x : POPB  R%-d            ; R[%-d]=0x%8x, SP=0x%x&quot;</span>, <span class="dt">$stime</span>, pc, ra, ra, R[ra], <span class="ot">`SP</span>);
          <span class="kw">end</span>
      <span class="kw">endcase</span>
  <span class="kw">end</span>
<span class="kw">endmodule</span>

<span class="kw">module</span> main;                <span class="co">// 測試程式開始</span>
<span class="dt">reg</span> clock;                  <span class="co">// 時脈 clock 變數</span>

cpu0c cpu(clock);           <span class="co">// 宣告 cpu0mc 處理器</span>

<span class="kw">initial</span> clock = <span class="dv">0</span>;          <span class="co">// 一開始 clock 設定為 0</span>
<span class="kw">always</span> <span class="bn">#10</span> clock=~clock;    <span class="co">// 每隔 10 奈秒將 clock 反相，產生週期為 20 奈秒的時脈</span>
<span class="kw">initial</span> <span class="bn">#2000</span> <span class="dt">$finish</span>;      <span class="co">// 在 640 奈秒的時候停止測試。(因為這時的 R[1] 恰好是 1+2+...+10=55 的結果)</span>
<span class="kw">endmodule</span></code></pre>
<h3 id="程式碼解析與執行"><a href="#程式碼解析與執行">程式碼解析與執行</a></h3>
<p>在上一期的 CPU0mc.v 當中，我們直接使用下列程式將「機器碼」塞入到記憶體當中，但是這樣做顯然彈性不太夠。</p>
<pre class="sourceCode verilog"><code class="sourceCode verilog">    {m[<span class="dv">0</span>],m[<span class="dv">1</span>],m[<span class="dv">2</span>],m[<span class="dv">3</span>]}    = <span class="bn">32&#39;h001F0018</span>; <span class="co">// 0000       LD   R1, K1</span>
    {m[<span class="dv">4</span>],m[<span class="dv">5</span>],m[<span class="dv">6</span>],m[<span class="dv">7</span>]}    = <span class="bn">32&#39;h002F0010</span>; <span class="co">// 0004       LD   R2, K0</span>
    {m[<span class="dv">8</span>],m[<span class="dv">9</span>],m[<span class="dv">10</span>],m[<span class="dv">11</span>]}  = <span class="bn">32&#39;h003F0014</span>; <span class="co">// 0008       LD   R3, SUM</span>
    {m[<span class="dv">12</span>],m[<span class="dv">13</span>],m[<span class="dv">14</span>],m[<span class="dv">15</span>]}= <span class="bn">32&#39;h13221000</span>; <span class="co">// 000C LOOP: ADD  R2, R2, R1</span>
    {m[<span class="dv">16</span>],m[<span class="dv">17</span>],m[<span class="dv">18</span>],m[<span class="dv">19</span>]}= <span class="bn">32&#39;h13332000</span>; <span class="co">// 0010       ADD  R3, R3, R2</span>
    {m[<span class="dv">20</span>],m[<span class="dv">21</span>],m[<span class="dv">22</span>],m[<span class="dv">23</span>]}= <span class="bn">32&#39;h26FFFFF4</span>; <span class="co">// 0014       JMP  LOOP</span>
    {m[<span class="dv">24</span>],m[<span class="dv">25</span>],m[<span class="dv">26</span>],m[<span class="dv">27</span>]}= <span class="bn">32&#39;h00000000</span>; <span class="co">// 0018 K0:   WORD 0</span>
    {m[<span class="dv">28</span>],m[<span class="dv">29</span>],m[<span class="dv">30</span>],m[<span class="dv">31</span>]}= <span class="bn">32&#39;h00000001</span>; <span class="co">// 001C K1:   WORD 1</span>
    {m[<span class="dv">32</span>],m[<span class="dv">33</span>],m[<span class="dv">34</span>],m[<span class="dv">35</span>]}= <span class="bn">32&#39;h00000000</span>; <span class="co">// 0020 SUM:  WORD 0</span></code></pre>
<p>因此，在本期的 CPU0sc.v 這個程式中，我們採用讀取外部檔案的方式，將機器碼寫在 「cpu0s.hex」這個檔案中， 然後再用下列指令將該 16 進位的機器碼檔案讀入。</p>
<pre class="sourceCode verilog"><code class="sourceCode verilog">    <span class="dt">$readmemh</span>(<span class="st">&quot;cpu0s.hex&quot;</span>, m);</code></pre>
<p>其中的 readmemh 是一個可以讀取 16 進位的文字檔的函數，上述指令會將 cpu0s.hex 這個檔案內的 16 進位字串 讀入到「記憶體變數」 m 當中。</p>
<p>以下是 cpu0s.hex 的完整內容。</p>
<p>輸入檔：cpu0s.hex</p>
<pre><code>00 DF 00 B6  //  0           LD   R13, StackEnd
08 40 00 04  //  4           ADDI R4, 4
08 50 00 08  //  8           ADDI R5, 8
05 4D 50 00  //  c           STR  R4, [R13+R5]
04 6D 50 00  // 10           LDR  R6, [R13+R5]
07 5D 40 00  // 14           SBR  R5, [R13+R4]
06 6D 40 00  // 18           LBR  R6, [R13+R4]
08 E0 FF FF  // 1C           ADDI R14,R0,-1
30 E0 00 00  // 20           PUSH R14
13 85 40 00  // 24           ADD  R8, R5, R4
14 85 40 00  // 28           SUB  R8, R5, R4
15 85 40 00  // 2c           MUL  R8, R5, R4
16 85 40 00  // 30           DIV  R8, R5, R4
18 85 40 00  // 34           AND  R8, R5, R4
19 85 40 00  // 38           OR   R8, R5, R4
1A 85 40 00  // 3c           XOR  R8, R5, R4
1E 85 00 03  // 40           SHL  R8, R5, 3
1F 85 00 02  // 44           SHR  R8, R5, 2
10 45 00 00  // 48           CMP  R4, R5
20 00 00 18  // 4c           JEQ  L1
23 00 00 14  // 50           JGT  L1
25 00 00 10  // 54           JGE  L1
22 00 00 0C  // 58           JLT  L1
24 00 00 08  // 5c           JLE  L1
21 00 00 04  // 60           JNE  L1
26 00 00 00  // 64           JMP  L1
08 10 00 0A  // 68   L1:     ADDI R1, R0, 10
2B 00 00 08  // 6c           CALL SUM
31 E0 00 00  // 70           POP  R14
2C 00 00 00  // 74           RET
30 E0 00 00  // 78   SUM:    PUSH R14
12 30 00 00  // 7c           MOV  R3, R0     // R3 = i = 0
02 4F 00 24  // 80           LDB  R4, k1     // R4 = 1
08 20 00 00  // 84           ADDI R2, 0      // SUM = R2 = 0
13 22 30 00  // 88   LOOP:   ADD  R2, R2, R3 // SUM = SUM + i
13 33 40 00  // 8c           ADD  R3, R3, R4 // i = i + 1
10 31 00 00  // 90           CMP  R3, R1     // if (i &lt; R1)
24 FF FF F0  // 94           JLE  LOOP       //   goto LOOP
01 2F 00 0D  // 98           ST   R2, s
03 3F 00 0D  // 9c           STB  R3, i
31 E0 00 00  // a0           POP  R14
2C 00 00 00  // a4           RET                   // return
01           // a8   k1:     BYTE 1                // char K1=1
00 00 00 00  // a9   s:      WORD 0                // int s
00           // ad   i:      BYTE 0                // char i=1
00 01 02 03  // ae   Stack:  BYTE  0, 1, 2, 3, 4, 5, 6, 7, 8, 9 , 10, 11
04 05 06 07  // b2
08 09 0A 0B  // b6
00 00 00 BA  // ba   StackEnd: WORD StackEnd
01 02 03 04  // be   Data:   BYTE 0, 1, 2, 3, 4, 5, 6, 7, 8
05 06 07 08  // c2</code></pre>
<p>上述程式的內容，大致是先準備好堆疊，然後就開始測試 ADDI, STR, LDR, ADD, SUB, ... 等指令。 接著在呼叫 CMP R4, R5 之後進行跳躍測試動作，由於 R4=4, R5=8，所以 CMP 的結果會是「小於」， 因此在後面的 JEQ, JGT, JGE 等指令都不會真的跳躍，直到執行 JLT L1 時就會真的跳到 L1 去。</p>
<p>接著用 ADDI R1, R0, 10 將 R1 設為 10，然後就用 CALL SUM 這個指令呼叫 SUM 這個副程式，於是跳到 位於 0x78 的 SUM: PUSH R14 這一行，並開始執行副程式，該副程式會計算 1+2+...+R1 的結果，放在 R2 當中， 並在最後用 STB R2, s 這個指令存入變數 s 當中，然後在執行完 RET 指令後返回上一層，也就是 0x70 行的 POP R14 指令，接著在執行 RET 指令時，由於此時 R14 為 -1，因此 Verilog 程式就在完成 RET 指令時發現 <code>PC 已經小於 0 了，因此執行</code>$finish` 指令停止整個程式。</p>
<pre class="sourceCode verilog"><code class="sourceCode verilog">        <span class="dv">RET:</span><span class="kw">begin</span>   <span class="co">// 返回;            RET;         PC &lt;= LR</span>
          <span class="ot">`PC</span>=<span class="ot">`LR</span>;
          <span class="dt">$display</span>(<span class="st">&quot;%4dns %8x : RET                  ; PC=0x%x&quot;</span>, <span class="dt">$stime</span>, pc, <span class="ot">`PC</span>);
          <span class="kw">if</span> (<span class="ot">`PC</span>&lt;<span class="dv">0</span>) <span class="dt">$finish</span>;
          <span class="kw">end</span></code></pre>
<h3 id="執行結果"><a href="#執行結果">執行結果</a></h3>
<p>有了上述的程式 cpu0sc.v 與輸入的機器碼 cpu0s.hex 檔案之後，我們就可以用下列指令進行編譯與執行， 以下是該程式編譯與執行的結果。</p>
<pre><code>D:\verilog&gt;iverilog -o cpu0sc cpu0sc.v

D:\verilog&gt;vvp cpu0sc
WARNING: cpu0sc.v:40: $readmemh(cpu0s.hex): Not enough words in the file for the
 requested range [0:256].
00000000: 00df00b6
00000004: 08400004
00000008: 08500008
0000000c: 054d5000
00000010: 046d5000
00000014: 075d4000
00000018: 066d4000
0000001c: 08e0ffff
00000020: 30e00000
00000024: 13854000
00000028: 14854000
0000002c: 15854000
00000030: 16854000
00000034: 18854000
00000038: 19854000
0000003c: 1a854000
00000040: 1e850003
00000044: 1f850002
00000048: 10450000
0000004c: 20000018
00000050: 23000014
00000054: 25000010
00000058: 2200000c
0000005c: 24000008
00000060: 21000004
00000064: 26000000
00000068: 0810000a
0000006c: 2b000008
00000070: 31e00000
00000074: 2c000000
00000078: 30e00000
0000007c: 12300000
00000080: 024f0024
00000084: 08200000
00000088: 13223000
0000008c: 13334000
00000090: 10310000
00000094: 24fffff0
00000098: 012f000d
0000009c: 033f000d
000000a0: 31e00000
000000a4: 2c000000
000000a8: 01000000
000000ac: 00000001
000000b0: 02030405
000000b4: 06070809
000000b8: 0a0b0000
000000bc: 00ba0102
000000c0: 03040506
000000c4: 0708xxxx
000000c8: xxxxxxxx
000000cc: xxxxxxxx
000000d0: xxxxxxxx
000000d4: xxxxxxxx
000000d8: xxxxxxxx
000000dc: xxxxxxxx
000000e0: xxxxxxxx
000000e4: xxxxxxxx
000000e8: xxxxxxxx
000000ec: xxxxxxxx
000000f0: xxxxxxxx
000000f4: xxxxxxxx
000000f8: xxxxxxxx
000000fc: xxxxxxxx
  10ns 00000000 : LD    R13 R15 0x00b6 ; R13=0x000000ba=186
  30ns 00000004 : ADDI  R4  R0  4      ; R4 =0x00000004=4
  50ns 00000008 : ADDI  R5  R0  8      ; R5 =0x00000008=8
  70ns 0000000c : STR   R4  R13 R5     ; R4 =0x00000004=4
  90ns 00000010 : LDR   R6  R13 R5     ; R6 =0x00000004=4
 110ns 00000014 : SBR   R5  R13 R4     ; R5 =0x00000008=8
 130ns 00000018 : LBR   R6  R13 R4     ; R6 =0x00000008=8
 150ns 0000001c : ADDI  R14 R0  -1     ; R14=0xffffffff=-1
 170ns 00000020 : PUSH  R14            ; R14=0xffffffff, SP=0x000000b6
 190ns 00000024 : ADD   R8  R5  R4     ; R8 =0x0000000c=12
 210ns 00000028 : SUB   R8  R5  R4     ; R8 =0x00000004=4
 230ns 0000002c : MUL   R8  R5  R4     ; R8 =0x00000020=32
 250ns 00000030 : DIV   R8  R5  R4     ; R8 =0x00000002=2
 270ns 00000034 : AND   R8  R5  R4     ; R8 =0x00000000=0
 290ns 00000038 : OR    R8  R5  R4     ; R8 =0x0000000c=12
 310ns 0000003c : XOR   R8  R5  R4     ; R8 =0x0000000c=12
 330ns 00000040 : SHL   R8  R5  3      ; R8 =0x00000040=64
 350ns 00000044 : SHR   R8  R5  2      ; R8 =0x00000002=2
 370ns 00000048 : CMP   R4  R5         ; SW=0x80000000
 390ns 0000004c : JEQ   0x00000018     ; PC=0x00000050
 410ns 00000050 : JGT   0x00000014     ; PC=0x00000054
 430ns 00000054 : JGE   0x00000010     ; PC=0x00000058
 450ns 00000058 : JLT   0x0000000c     ; PC=0x00000068
 470ns 00000068 : ADDI  R1  R0  10     ; R1 =0x0000000a=10
 490ns 0000006c : CALL  0x00000008     ; PC=0x00000078
 510ns 00000078 : PUSH  R14            ; R14=0x00000070, SP=0x000000b2
 530ns 0000007c : MOV   R3  R0         ; R3 =0x00000000=0
 550ns 00000080 : LDB   R4  R15 0x0024 ; R4 =0x00000001=1
 570ns 00000084 : ADDI  R2  R0  0      ; R2 =0x00000000=0
 590ns 00000088 : ADD   R2  R2  R3     ; R2 =0x00000000=0
 610ns 0000008c : ADD   R3  R3  R4     ; R3 =0x00000001=1
 630ns 00000090 : CMP   R3  R1         ; SW=0x80000000
 650ns 00000094 : JLE   0x00fffff0     ; PC=0x00000088
 670ns 00000088 : ADD   R2  R2  R3     ; R2 =0x00000001=1
 690ns 0000008c : ADD   R3  R3  R4     ; R3 =0x00000002=2
 710ns 00000090 : CMP   R3  R1         ; SW=0x80000000
 730ns 00000094 : JLE   0x00fffff0     ; PC=0x00000088
 750ns 00000088 : ADD   R2  R2  R3     ; R2 =0x00000003=3
 770ns 0000008c : ADD   R3  R3  R4     ; R3 =0x00000003=3
 790ns 00000090 : CMP   R3  R1         ; SW=0x80000000
 810ns 00000094 : JLE   0x00fffff0     ; PC=0x00000088
 830ns 00000088 : ADD   R2  R2  R3     ; R2 =0x00000006=6
 850ns 0000008c : ADD   R3  R3  R4     ; R3 =0x00000004=4
 870ns 00000090 : CMP   R3  R1         ; SW=0x80000000
 890ns 00000094 : JLE   0x00fffff0     ; PC=0x00000088
 910ns 00000088 : ADD   R2  R2  R3     ; R2 =0x0000000a=10
 930ns 0000008c : ADD   R3  R3  R4     ; R3 =0x00000005=5
 950ns 00000090 : CMP   R3  R1         ; SW=0x80000000
 970ns 00000094 : JLE   0x00fffff0     ; PC=0x00000088
 990ns 00000088 : ADD   R2  R2  R3     ; R2 =0x0000000f=15
1010ns 0000008c : ADD   R3  R3  R4     ; R3 =0x00000006=6
1030ns 00000090 : CMP   R3  R1         ; SW=0x80000000
1050ns 00000094 : JLE   0x00fffff0     ; PC=0x00000088
1070ns 00000088 : ADD   R2  R2  R3     ; R2 =0x00000015=21
1090ns 0000008c : ADD   R3  R3  R4     ; R3 =0x00000007=7
1110ns 00000090 : CMP   R3  R1         ; SW=0x80000000
1130ns 00000094 : JLE   0x00fffff0     ; PC=0x00000088
1150ns 00000088 : ADD   R2  R2  R3     ; R2 =0x0000001c=28
1170ns 0000008c : ADD   R3  R3  R4     ; R3 =0x00000008=8
1190ns 00000090 : CMP   R3  R1         ; SW=0x80000000
1210ns 00000094 : JLE   0x00fffff0     ; PC=0x00000088
1230ns 00000088 : ADD   R2  R2  R3     ; R2 =0x00000024=36
1250ns 0000008c : ADD   R3  R3  R4     ; R3 =0x00000009=9
1270ns 00000090 : CMP   R3  R1         ; SW=0x80000000
1290ns 00000094 : JLE   0x00fffff0     ; PC=0x00000088
1310ns 00000088 : ADD   R2  R2  R3     ; R2 =0x0000002d=45
1330ns 0000008c : ADD   R3  R3  R4     ; R3 =0x0000000a=10
1350ns 00000090 : CMP   R3  R1         ; SW=0x40000000
1370ns 00000094 : JLE   0x00fffff0     ; PC=0x00000088
1390ns 00000088 : ADD   R2  R2  R3     ; R2 =0x00000037=55
1410ns 0000008c : ADD   R3  R3  R4     ; R3 =0x0000000b=11
1430ns 00000090 : CMP   R3  R1         ; SW=0x00000000
1450ns 00000094 : JLE   0x00fffff0     ; PC=0x00000098
1470ns 00000098 : ST    R2  R15 0x000d ; R2 =0x00000037=55
1490ns 0000009c : STB   R3  R15 0x000d ; R3 =0x0000000b=11
1510ns 000000a0 : POP   R14            ; R14=0x00000070, SP=0x000000b6
1530ns 000000a4 : RET                  ; PC=0x00000070
1550ns 00000070 : POP   R14            ; R14=0xffffffff, SP=0x000000ba
1570ns 00000074 : RET                  ; PC=0xffffffff</code></pre>
<h3 id="結語"><a href="#結語">結語</a></h3>
<p>從這兩期的程式中，您應該可以瞭解到直接使用高階的 Verilog 流程式語法來設計處理器，像是 cpu0mc.v 與 cpu0sc.v ， 都是相當容易的事，這完全是因為 verilog 支援了相當高階的運算，像是 「+, -, *, /, &amp;, |, ^, &lt;&lt;, &gt;&gt;」等運算的原故。</p>
<p>不過、在上述程式當中，我們並沒有支援「硬體中斷」的功能，也沒有實作「軟體中斷」SWI 的函數呼叫，這樣 CPU0sc.v 就 只能是一顆單工 (Single Task) 的處理器，而無法支援多工 (Multi Task) 的功能了。</p>
<p>在下期中，我們將繼續擴充 CPU0sc.v 這個程式，加入支援「軟硬體中斷」的功能，該程式稱為 CPU0ic.v (i 代表 Interrupt, c 代表 cache memory)。</p>
<p>然後我們將再度用 16 進位的方式，寫出一個機器語言的程式，可以同時執行兩個「行程」(Task) ，並且每隔一小段時間就利用 硬體中斷進行「行程切換」，以示範如何設計一個可以支援「多工」能力的 CPU 處理器。</p>
<h3 id="參考文獻"><a href="#參考文獻">參考文獻</a></h3>
<ul>
<li><a href="http://ccckmit.wikidot.com/ve:cpu0s">陳鍾誠的網站：使用 Verilog 設計 CPU0 處理器</a></li>
<li><a href="http://ccckmit.wikidot.com/ve:cpu0m">陳鍾誠的網站：CPU0-Mini 處理器設計</a></li>
</ul>
</div>
<div id="footer">
<a href="https://www.facebook.com/groups/programmerMagazine/">程式人雜誌</a> ，採用 <a href="http://creativecommons.org/licenses/by-sa/3.0/tw/ ">創作共用：姓名標示、相同方式分享</a> 授權，歡迎加入 <a href="https://www.facebook.com/groups/programmerMagazine/">雜誌社團</a>
</div>
</body>
</html>
