<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <meta name="generator" content="pandoc" />
  <title></title>
  <style type="text/css">code{white-space: pre;}</style>
  <style type="text/css">
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
table.sourceCode { width: 100%; line-height: 100%; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
code > span.kw { color: #007020; font-weight: bold; }
code > span.dt { color: #902000; }
code > span.dv { color: #40a070; }
code > span.bn { color: #40a070; }
code > span.fl { color: #40a070; }
code > span.ch { color: #4070a0; }
code > span.st { color: #4070a0; }
code > span.co { color: #60a0b0; font-style: italic; }
code > span.ot { color: #007020; }
code > span.al { color: #ff0000; font-weight: bold; }
code > span.fu { color: #06287e; }
code > span.er { color: #ff0000; font-weight: bold; }
  </style>
  <link rel="stylesheet" href="../css/pmag.css" type="text/css" />
</head>
<body>
<div id="header_wrap">
   <h1><a href="https://www.facebook.com/groups/programmerMagazine">程式人雜誌</a> <sub> --  <a href="https://dl.dropbox.com/u/101584453/pmag/201311/htm/home.html">2013 年 11 月號</a> (開放公益出版品)</sub></h1>
</div>
<div id="content">
<div id="TOC">
<ul>
<li><a href="#verilog-5-邊緣觸發正反器-作者陳鍾誠">Verilog (5) – 邊緣觸發正反器 (作者：陳鍾誠)</a></li>
</ul>
</div>
<h2 id="verilog-5-邊緣觸發正反器-作者陳鍾誠"><a href="#verilog-5-邊緣觸發正反器-作者陳鍾誠">Verilog (5) – 邊緣觸發正反器 (作者：陳鍾誠)</a></h2>
<p>在本文中，我們將介紹如何用 Verilog 實作兩種概念，第一個是正反器 (Latch, Flip-Flop)，第二個是脈波變化偵測器 (Pulse Transition Detector)，然後再用這兩個元件組合成「邊緣觸發正反器」 (Edge Triggered Flip-Flop)。</p>
<h3 id="正反器"><a href="#正反器">正反器</a></h3>
<p>正反器是可以用來儲存位元，是循序電路的基礎，以下是一個用 NAND 閘構成的正反器。</p>
<div class="figure">
<img src="../img/nandLatch.png" alt="圖、NAND 閘構成的正反器" /><p class="caption">圖、NAND 閘構成的正反器</p>
</div>
<p>我們可以根據上圖實作出對應的 Verilog 程式如下：</p>
<p>檔案：latch.v</p>
<pre class="sourceCode verilog"><code class="sourceCode verilog"><span class="kw">module</span> latch(<span class="dt">input</span> Sbar, Rbar, <span class="dt">output</span> Q, Qbar);
  <span class="dt">nand</span> LS(Q, Sbar, Qbar);
  <span class="dt">nand</span> LR(Qbar, Rbar, Q);
<span class="kw">endmodule</span>

<span class="kw">module</span> main;
<span class="dt">reg</span> Sbar, Rbar;
<span class="dt">wire</span> Q, Qbar;

latch latch1(Sbar, Rbar, Q, Qbar);

<span class="kw">initial</span>
<span class="kw">begin</span>
  <span class="dt">$monitor</span>(<span class="st">&quot;%4dns monitor: Sbar=%d Rbar=%d Q=%d Qbar=%d&quot;</span>, <span class="dt">$stime</span>, Sbar, Rbar, Q, Qbar);
  <span class="dt">$dumpfile</span>(<span class="st">&quot;latch.vcd&quot;</span>); <span class="co">// 輸出給 GTK wave 顯示波型</span>
  <span class="dt">$dumpvars</span>;    
<span class="kw">end</span>

<span class="kw">always</span> <span class="bn">#50</span> <span class="kw">begin</span>
  Sbar = <span class="dv">0</span>; Rbar = <span class="dv">1</span>;
  <span class="bn">#50</span>;
  Sbar = <span class="dv">1</span>; Rbar = <span class="dv">1</span>;
  <span class="bn">#50</span>;
  Sbar = <span class="dv">1</span>; Rbar = <span class="dv">0</span>;
  <span class="bn">#50</span>;
<span class="kw">end</span>

<span class="kw">initial</span> <span class="bn">#500</span> <span class="dt">$finish</span>;

<span class="kw">endmodule</span></code></pre>
<p>執行結果：</p>
<pre><code>D:\verilog&gt;iverilog -o latch latch.v

D:\verilog&gt;vvp latch
VCD info: dumpfile latch.vcd opened for output.
   0ns monitor: Sbar=x Rbar=x Q=x Qbar=x
  50ns monitor: Sbar=0 Rbar=1 Q=1 Qbar=0
 100ns monitor: Sbar=1 Rbar=1 Q=1 Qbar=0
 150ns monitor: Sbar=1 Rbar=0 Q=0 Qbar=1
 250ns monitor: Sbar=0 Rbar=1 Q=1 Qbar=0
 300ns monitor: Sbar=1 Rbar=1 Q=1 Qbar=0
 350ns monitor: Sbar=1 Rbar=0 Q=0 Qbar=1
 450ns monitor: Sbar=0 Rbar=1 Q=1 Qbar=0
 500ns monitor: Sbar=1 Rbar=1 Q=1 Qbar=0</code></pre>
<div class="figure">
<img src="../img/latchWave.jpg" alt="圖、latch.vcd 的顯示圖形" /><p class="caption">圖、latch.vcd 的顯示圖形</p>
</div>
<h3 id="有-enable-的正反器"><a href="#有-enable-的正反器">有 enable 的正反器</a></h3>
<p>如果我們在上述正反器前面再加上兩個 NAND 閘進行控制，就可以形成一組有 enable 的正反器，以下是該正反器的圖形。</p>
<div class="figure">
<img src="../img/enLatch.jpg" alt="圖、有 enable 的正反器" /><p class="caption">圖、有 enable 的正反器</p>
</div>
<p>根據上述圖形我們可以設計出以下的 Verilog 程式。</p>
<p>檔案：enLatch.v</p>
<pre class="sourceCode verilog"><code class="sourceCode verilog"><span class="kw">module</span> latch(<span class="dt">input</span> Sbar, Rbar, <span class="dt">output</span> Q, Qbar);
  <span class="dt">nand</span> LS(Q, Sbar, Qbar);
  <span class="dt">nand</span> LR(Qbar, Rbar, Q);
<span class="kw">endmodule</span>

<span class="kw">module</span> enLatch(<span class="dt">input</span> en, S, R, <span class="dt">output</span> Q, Qbar);
  <span class="dt">nand</span> ES(Senbar, en, S);
  <span class="dt">nand</span> ER(Renbar, en, R);
  latch L1(Senbar, Renbar, Q, Qbar);
<span class="kw">endmodule</span>

<span class="kw">module</span> main;
<span class="dt">reg</span> S, en, R;
<span class="dt">wire</span> Q, Qbar;

enLatch enLatch1(en, S, R, Q, Qbar);

<span class="kw">initial</span>
<span class="kw">begin</span>
  <span class="dt">$monitor</span>(<span class="st">&quot;%4dns monitor: en=%d S=%d R=%d Q=%d Qbar=%d&quot;</span>, <span class="dt">$stime</span>, en, S, R, Q, Qbar);
  <span class="dt">$dumpfile</span>(<span class="st">&quot;enLatch.vcd&quot;</span>); <span class="co">// 輸出給 GTK wave 顯示波型</span>
  <span class="dt">$dumpvars</span>;    
<span class="kw">end</span>

<span class="kw">always</span> <span class="bn">#50</span> <span class="kw">begin</span>
  en = <span class="dv">1</span>;
  <span class="bn">#50</span>;
  S = <span class="dv">1</span>; R = <span class="dv">0</span>;
  <span class="bn">#50</span>;
  S = <span class="dv">0</span>; R = <span class="dv">0</span>;
  <span class="bn">#50</span>;
  S = <span class="dv">0</span>; R = <span class="dv">1</span>;
  <span class="bn">#50</span>
  en = <span class="dv">0</span>;
  <span class="bn">#50</span>;
  S = <span class="dv">1</span>; R = <span class="dv">0</span>;
  <span class="bn">#50</span>;
  S = <span class="dv">0</span>; R = <span class="dv">0</span>;
  <span class="bn">#50</span>;
  S = <span class="dv">0</span>; R = <span class="dv">1</span>;
<span class="kw">end</span>

<span class="kw">initial</span> <span class="bn">#1000</span> <span class="dt">$finish</span>;

<span class="kw">endmodule</span></code></pre>
<p>執行結果</p>
<pre><code>D:\verilog&gt;iverilog -o enLatch enLatch.v

D:\verilog&gt;vvp enLatch
VCD info: dumpfile enLatch.vcd opened for output.
   0ns monitor: en=x Sbar=x Rbar=x Q=x Qbar=x
  50ns monitor: en=1 Sbar=x Rbar=x Q=x Qbar=x
 100ns monitor: en=1 Sbar=1 Rbar=0 Q=1 Qbar=0
 150ns monitor: en=1 Sbar=0 Rbar=0 Q=1 Qbar=0
 200ns monitor: en=1 Sbar=0 Rbar=1 Q=0 Qbar=1
 250ns monitor: en=0 Sbar=0 Rbar=1 Q=0 Qbar=1
 300ns monitor: en=0 Sbar=1 Rbar=0 Q=0 Qbar=1
 350ns monitor: en=0 Sbar=0 Rbar=0 Q=0 Qbar=1
 400ns monitor: en=0 Sbar=0 Rbar=1 Q=0 Qbar=1
 450ns monitor: en=1 Sbar=0 Rbar=1 Q=0 Qbar=1
 500ns monitor: en=1 Sbar=1 Rbar=0 Q=1 Qbar=0
 550ns monitor: en=1 Sbar=0 Rbar=0 Q=1 Qbar=0
 600ns monitor: en=1 Sbar=0 Rbar=1 Q=0 Qbar=1
 650ns monitor: en=0 Sbar=0 Rbar=1 Q=0 Qbar=1
 700ns monitor: en=0 Sbar=1 Rbar=0 Q=0 Qbar=1
 750ns monitor: en=0 Sbar=0 Rbar=0 Q=0 Qbar=1
 800ns monitor: en=0 Sbar=0 Rbar=1 Q=0 Qbar=1
 850ns monitor: en=1 Sbar=0 Rbar=1 Q=0 Qbar=1
 900ns monitor: en=1 Sbar=1 Rbar=0 Q=1 Qbar=0
 950ns monitor: en=1 Sbar=0 Rbar=0 Q=1 Qbar=0
1000ns monitor: en=1 Sbar=0 Rbar=1 Q=0 Qbar=1</code></pre>
<div class="figure">
<img src="../img/enLatchWave.jpg" alt="圖、enLatch.vcd 的顯示圖形" /><p class="caption">圖、enLatch.vcd 的顯示圖形</p>
</div>
<h3 id="脈波變化偵測器-pulse-transition-detector-ptd"><a href="#脈波變化偵測器-pulse-transition-detector-ptd">脈波變化偵測器 (Pulse Transition Detector, PTD)</a></h3>
<p>傳統上，要做邊緣觸發的正反器，必須使用 Master-Slave 的架構，這樣要消耗較多的邏輯閘，但是現在通常改用 「脈波變化偵測電路」來偵測時脈的邊緣，這樣不僅可以簡化電路，而且適用性也更廣、更好用，因為任何需要偵測邊緣的地方都可以使用這樣的電路進行偵測。</p>
<p>以下是「脈波變化偵測電路」的圖形，其中的關鍵是在 左邊的 not 閘身上，由於每個閘都會造成延遲，因此多了 not 閘的那條路徑所造成的延遲較多，這讓輸出部份會因為延遲而形成一個脈衝波形。</p>
<div class="figure">
<img src="../img/ptd.jpg" alt="圖、脈波變化偵測器" /><p class="caption">圖、脈波變化偵測器</p>
</div>
<p>以下是這個電路以 Verilog 實作的結果。</p>
<p>檔案：ptd.v</p>
<pre class="sourceCode verilog"><code class="sourceCode verilog"><span class="kw">module</span> ptd(<span class="dt">input</span> clk, <span class="dt">output</span> ppulse);
  <span class="dt">not</span> <span class="bn">#2</span> P1(nclkd, clk);
  <span class="dt">nand</span> <span class="bn">#2</span> P2(npulse, nclkd, clk);
  <span class="dt">not</span> <span class="bn">#2</span> P3(ppulse, npulse);
<span class="kw">endmodule</span>

<span class="kw">module</span> main;
 <span class="dt">reg</span> clk;
 <span class="dt">wire</span> p;

 ptd ptd1(clk, p);

 <span class="kw">initial</span> <span class="kw">begin</span>
   clk = <span class="dv">0</span>;
   <span class="dt">$monitor</span>(<span class="st">&quot;%dns monitor: clk=%b p=%d&quot;</span>, <span class="dt">$stime</span>, clk, p);
   <span class="dt">$dumpfile</span>(<span class="st">&quot;ptd.vcd&quot;</span>); <span class="co">// 輸出給 GTK wave 顯示波型</span>
   <span class="dt">$dumpvars</span>;
 <span class="kw">end</span>

 <span class="kw">always</span> <span class="bn">#50</span> <span class="kw">begin</span>
   clk = clk + <span class="dv">1</span>;
 <span class="kw">end</span>

<span class="kw">initial</span> <span class="bn">#500</span> <span class="dt">$finish</span>;

<span class="kw">endmodule</span></code></pre>
<p>執行結果</p>
<pre><code>D:\Dropbox\Public\pmag\201311\code&gt;iverilog -o ptd ptd.v

D:\Dropbox\Public\pmag\201311\code&gt;vvp ptd
VCD info: dumpfile ptd.vcd opened for output.
         0ns monitor: clk=0 p=z
         4ns monitor: clk=0 p=0
        50ns monitor: clk=1 p=0
        54ns monitor: clk=1 p=1
        56ns monitor: clk=1 p=0
       100ns monitor: clk=0 p=0
       150ns monitor: clk=1 p=0
       154ns monitor: clk=1 p=1
       156ns monitor: clk=1 p=0
       200ns monitor: clk=0 p=0
       250ns monitor: clk=1 p=0
       254ns monitor: clk=1 p=1
       256ns monitor: clk=1 p=0
       300ns monitor: clk=0 p=0
       350ns monitor: clk=1 p=0
       354ns monitor: clk=1 p=1
       356ns monitor: clk=1 p=0
       400ns monitor: clk=0 p=0
       450ns monitor: clk=1 p=0
       454ns monitor: clk=1 p=1
       456ns monitor: clk=1 p=0
       500ns monitor: clk=0 p=0</code></pre>
<div class="figure">
<img src="../img/ptdWave.jpg" alt="圖、ptd.vcd 的顯示圖形" /><p class="caption">圖、ptd.vcd 的顯示圖形</p>
</div>
<h3 id="邊緣觸發的正反器"><a href="#邊緣觸發的正反器">邊緣觸發的正反器</a></h3>
<p>有了「正反器」與「脈波變化偵測電路」之後，我們就可以組合出「邊緣觸發正反器」了，以下是其電路圖。</p>
<div class="figure">
<img src="../img/ptdLatch.jpg" alt="圖、邊緣觸發的正反器" /><p class="caption">圖、邊緣觸發的正反器</p>
</div>
<p>事實上，上述電路圖只是將「有 enable 的正反器」前面加上一個「脈波變化偵測電路」而已，其實做的 Verilog 程式如下。</p>
<p>檔案：ptdLatch.v</p>
<pre class="sourceCode verilog"><code class="sourceCode verilog"><span class="kw">module</span> latch(<span class="dt">input</span> Sbar, Rbar, <span class="dt">output</span> Q, Qbar);
  <span class="dt">nand</span> LS(Q, Sbar, Qbar);
  <span class="dt">nand</span> LR(Qbar, Rbar, Q);
<span class="kw">endmodule</span>

<span class="kw">module</span> enLatch(<span class="dt">input</span> en, S, R, <span class="dt">output</span> Q, Qbar);
  <span class="dt">nand</span> ES(Senbar, en, S);
  <span class="dt">nand</span> ER(Renbar, en, R);
  latch L1(Senbar, Renbar, Q, Qbar);
<span class="kw">endmodule</span>

<span class="kw">module</span> ptd(<span class="dt">input</span> clk, <span class="dt">output</span> ppulse);
  <span class="dt">not</span>  <span class="bn">#2</span> P1(nclkd, clk);
  <span class="dt">nand</span> <span class="bn">#2</span> P2(npulse, nclkd, clk);
  <span class="dt">not</span>  <span class="bn">#2</span> P3(ppulse, npulse);
<span class="kw">endmodule</span>

<span class="kw">module</span> ptdLatch(<span class="dt">input</span> clk, S, R, <span class="dt">output</span> Q, Qbar);
  ptd PTD(clk, ppulse);
  enLatch EL(ppulse, S, R, Q, Qbar);
<span class="kw">endmodule</span>

<span class="kw">module</span> main;
<span class="dt">reg</span> S, clk, R;
<span class="dt">wire</span> Q, Qbar;

ptdLatch ptdLatch1(clk, S, R, Q, Qbar);

<span class="kw">initial</span>
<span class="kw">begin</span>
  clk = <span class="dv">0</span>;
  <span class="dt">$monitor</span>(<span class="st">&quot;%4dns monitor: clk=%d ppulse=%d S=%d R=%d Q=%d Qbar=%d&quot;</span>, <span class="dt">$stime</span>, clk, ptdLatch1.ppulse, S, R, Q, Qbar);
  <span class="dt">$dumpfile</span>(<span class="st">&quot;ptdLatch.vcd&quot;</span>); <span class="co">// 輸出給 GTK wave 顯示波型</span>
  <span class="dt">$dumpvars</span>;    
<span class="kw">end</span>

<span class="kw">always</span> <span class="bn">#20</span> <span class="kw">begin</span>
  clk = ~clk;
<span class="kw">end</span>

<span class="kw">always</span> <span class="bn">#50</span> <span class="kw">begin</span>
  S = <span class="dv">1</span>; R = <span class="dv">0</span>;
  <span class="bn">#50</span>;
  S = <span class="dv">0</span>; R = <span class="dv">0</span>;
  <span class="bn">#50</span>;
  S = <span class="dv">0</span>; R = <span class="dv">1</span>;
  <span class="bn">#50</span>;
<span class="kw">end</span>

<span class="kw">initial</span> <span class="bn">#500</span> <span class="dt">$finish</span>;

<span class="kw">endmodule</span></code></pre>
<p>執行結果</p>
<pre><code>D:\verilog&gt;iverilog -o ptdLatch ptdLatch.v

D:\verilog&gt;vvp ptdLatch
VCD info: dumpfile ptdLatch.vcd opened for output.
   0ns monitor: clk=0 ppulse=z S=x R=x Q=x Qbar=x
   4ns monitor: clk=0 ppulse=0 S=x R=x Q=x Qbar=x
  20ns monitor: clk=1 ppulse=0 S=x R=x Q=x Qbar=x
  24ns monitor: clk=1 ppulse=1 S=x R=x Q=x Qbar=x
  26ns monitor: clk=1 ppulse=0 S=x R=x Q=x Qbar=x
  40ns monitor: clk=0 ppulse=0 S=x R=x Q=x Qbar=x
  50ns monitor: clk=0 ppulse=0 S=1 R=0 Q=x Qbar=x
  60ns monitor: clk=1 ppulse=0 S=1 R=0 Q=x Qbar=x
  64ns monitor: clk=1 ppulse=1 S=1 R=0 Q=1 Qbar=0
  66ns monitor: clk=1 ppulse=0 S=1 R=0 Q=1 Qbar=0
  80ns monitor: clk=0 ppulse=0 S=1 R=0 Q=1 Qbar=0
 100ns monitor: clk=1 ppulse=0 S=0 R=0 Q=1 Qbar=0
 104ns monitor: clk=1 ppulse=1 S=0 R=0 Q=1 Qbar=0
 106ns monitor: clk=1 ppulse=0 S=0 R=0 Q=1 Qbar=0
 120ns monitor: clk=0 ppulse=0 S=0 R=0 Q=1 Qbar=0
 140ns monitor: clk=1 ppulse=0 S=0 R=0 Q=1 Qbar=0
 144ns monitor: clk=1 ppulse=1 S=0 R=0 Q=1 Qbar=0
 146ns monitor: clk=1 ppulse=0 S=0 R=0 Q=1 Qbar=0
 150ns monitor: clk=1 ppulse=0 S=0 R=1 Q=1 Qbar=0
 160ns monitor: clk=0 ppulse=0 S=0 R=1 Q=1 Qbar=0
 180ns monitor: clk=1 ppulse=0 S=0 R=1 Q=1 Qbar=0
 184ns monitor: clk=1 ppulse=1 S=0 R=1 Q=0 Qbar=1
 186ns monitor: clk=1 ppulse=0 S=0 R=1 Q=0 Qbar=1
 200ns monitor: clk=0 ppulse=0 S=0 R=1 Q=0 Qbar=1
 220ns monitor: clk=1 ppulse=0 S=0 R=1 Q=0 Qbar=1
 224ns monitor: clk=1 ppulse=1 S=0 R=1 Q=0 Qbar=1
 226ns monitor: clk=1 ppulse=0 S=0 R=1 Q=0 Qbar=1
 240ns monitor: clk=0 ppulse=0 S=0 R=1 Q=0 Qbar=1
 250ns monitor: clk=0 ppulse=0 S=1 R=0 Q=0 Qbar=1
 260ns monitor: clk=1 ppulse=0 S=1 R=0 Q=0 Qbar=1
 264ns monitor: clk=1 ppulse=1 S=1 R=0 Q=1 Qbar=0
 266ns monitor: clk=1 ppulse=0 S=1 R=0 Q=1 Qbar=0
 280ns monitor: clk=0 ppulse=0 S=1 R=0 Q=1 Qbar=0
 300ns monitor: clk=1 ppulse=0 S=0 R=0 Q=1 Qbar=0
 304ns monitor: clk=1 ppulse=1 S=0 R=0 Q=1 Qbar=0
 306ns monitor: clk=1 ppulse=0 S=0 R=0 Q=1 Qbar=0
 320ns monitor: clk=0 ppulse=0 S=0 R=0 Q=1 Qbar=0
 340ns monitor: clk=1 ppulse=0 S=0 R=0 Q=1 Qbar=0
 344ns monitor: clk=1 ppulse=1 S=0 R=0 Q=1 Qbar=0
 346ns monitor: clk=1 ppulse=0 S=0 R=0 Q=1 Qbar=0
 350ns monitor: clk=1 ppulse=0 S=0 R=1 Q=1 Qbar=0
 360ns monitor: clk=0 ppulse=0 S=0 R=1 Q=1 Qbar=0
 380ns monitor: clk=1 ppulse=0 S=0 R=1 Q=1 Qbar=0
 384ns monitor: clk=1 ppulse=1 S=0 R=1 Q=0 Qbar=1
 386ns monitor: clk=1 ppulse=0 S=0 R=1 Q=0 Qbar=1
 400ns monitor: clk=0 ppulse=0 S=0 R=1 Q=0 Qbar=1
 420ns monitor: clk=1 ppulse=0 S=0 R=1 Q=0 Qbar=1
 424ns monitor: clk=1 ppulse=1 S=0 R=1 Q=0 Qbar=1
 426ns monitor: clk=1 ppulse=0 S=0 R=1 Q=0 Qbar=1
 440ns monitor: clk=0 ppulse=0 S=0 R=1 Q=0 Qbar=1
 450ns monitor: clk=0 ppulse=0 S=1 R=0 Q=0 Qbar=1
 460ns monitor: clk=1 ppulse=0 S=1 R=0 Q=0 Qbar=1
 464ns monitor: clk=1 ppulse=1 S=1 R=0 Q=1 Qbar=0
 466ns monitor: clk=1 ppulse=0 S=1 R=0 Q=1 Qbar=0
 480ns monitor: clk=0 ppulse=0 S=1 R=0 Q=1 Qbar=0
 500ns monitor: clk=1 ppulse=0 S=0 R=0 Q=1 Qbar=0</code></pre>
<div class="figure">
<img src="../img/ptdLatchWave.jpg" alt="圖、ptdLatch.vcd 的顯示圖形" /><p class="caption">圖、ptdLatch.vcd 的顯示圖形</p>
</div>
<h3 id="結語"><a href="#結語">結語</a></h3>
<p>有了「脈波變化偵測電路」，只要與任何需要偵測脈波變化的元件串接起來，就可以達到「邊緣觸發」的功能。</p>
<p>其實、像是 Verilog 當中的以下程式，其實都是利用類似的「脈波變化偵測電路」所完成的。</p>
<pre class="sourceCode verilog"><code class="sourceCode verilog">  <span class="kw">always</span> @(<span class="kw">posedge</span> clock) <span class="kw">begin</span>
  ...
  <span class="kw">end</span></code></pre>
<h3 id="參考文獻"><a href="#參考文獻">參考文獻</a></h3>
<ul>
<li><a href="http://ccckmit.wikidot.com/ve:ptd">陳鍾誠的網站：脈衝偵測電路</a></li>
</ul>
<p>【本文圖片修改自 <a href="http://zh.wikipedia.org/">維基百科</a>，採用創作共用的 <a href="http://creativecommons.org/licenses/by-sa/3.0/tw/">姓名標示、相同方式分享</a> 授權】</p>
</div>
<div id="footer">
<a href="https://www.facebook.com/groups/programmerMagazine/">程式人雜誌</a> ，採用 <a href="http://creativecommons.org/licenses/by-sa/3.0/tw/ ">創作共用：姓名標示、相同方式分享</a> 授權，歡迎加入 <a href="https://www.facebook.com/groups/programmerMagazine/">雜誌社團</a>
</div>
</body>
</html>
